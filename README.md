# Firestore トランザクション検証環境

## 概要について
このプロジェクトはFirestoreの悲観ロックの挙動を確認するためのテストである。
N枚のチケットを購入するためにM人のユーザーが殺到するケースを想定し、トランザクション制御の挙動を検証する。

## Firestoreの悲観ロックの挙動について
Firestoreの「悲観ロック」は、実質的には楽観ロックに近い挙動をする。以下がその特徴と注意点。

### 挙動の特徴

- **ロックの範囲**
  - トランザクション内でドキュメントを取得すると、ドキュメントにロックがかかる
  - ただし、これは他のトランザクションによる「更新」をブロックするのみで、「読み取り」は制限されない

- **同時アクセス時の挙動**
  - 複数のトランザクションが同じドキュメントを同時に取得可能
  - その結果、同じデータを購入可能と判断して処理を進める

- **競合時の再実行**
  - 更新時にロック獲得を試み、別のトランザクションによる更新を検知するとトランザクション全体が再実行される

- **リトライ制限**
  - トランザクションのリトライが10回を超えるとタイムアウトエラーが発生

### 他のデータベースとの違い

- MySQLなどで実現できるSELECT FOR UPDATEのような「読み取りロック」による順序制御はFirestoreではサポートされない
- Firestoreはスケーラビリティを重視して設計されており、実行コストの高い読み取りのロックは実装されていない

### 結論

Firestoreで読み取りを含む順序制御を実現するには、データベースの機能だけでは不十分であり、自前で順序制御のロジックを実装する必要がある。

## Firestoreでの順序処理の実現方法について
自前のキューイングの仕組みを実装するのが実装コスト低くできる方法になる。

今回実装した処理の流れは下記である。
 - キューイング用のコレクションに対して、自分のドキュメントを登録する
 - 定期的にポーリングして自分の番が回ってくるのを待つ
 - 自分の番が回ってきたらトランザクション処理を実行
 - トランザクション処理終了後、成功失敗に関わらず最後に削除

### 実装した主な関数

`addTransactionQueue`: キューにトランザクションを追加する。
`deleteTransactionQueue`: トランザクションが完了した後にキューから削除する。
`isMinExpiresAt`: 現在のキュー内で自分が最優先かを判定する。
`waitForTurn`: 自分の順番が来るまで定期的に確認する。
### 実装時に考慮するべきポイント
ポーリングにおけるリトライ間隔やタイムアウト値のチューニングが、キューの動作を安定させる上で重要となる。
#### ポーリング間隔の設定
- ポーリング間隔が短すぎるとFirestoreへのリクエストが過剰になり負荷が高くなる
- 間隔が長すぎると処理遅延が発生する
- 適切な間隔を設定する必要がある

#### リトライ回数の上限
- リトライの回数が少ないと、意図せず早くtimeoutを迎えてしまい、処理が完了するはずだったトランザクションが失敗してしまう
- リトライの上限が多いと順番待ちのトランザクションがタイムアウトを繰り返し、意図した処理が完了しない可能性が高くなる

#### 破棄されないキューの対応
- ネットワークエラーやシステム障害によって、意図せず削除されなかったキューが残る場合に備える必要がある
- タイムスタンプを基に一定時間経過後に無効化する仕組みを追加することで、この問題を回避できる

## 今回のテストコードについて

### プロジェクト構成
本プロジェクトはDockerを使用してFirestore Emulatorとテストアプリケーションをコンテナとして構築している。

#### インフラストラクチャ
- Firestore Emulatorコンテナ (ポート8080でFirestoreをエミュレート)
- テストアプリケーションコンテナ (Node.js実装)

#### アプリケーション構成
テストアプリケーションは以下のコレクションと機能で構成している:

**Firestoreコレクション:**
- `tickets`: チケット情報を管理するコレクション
- `que`: 順序制御のためのキューイング用コレクション

**主要機能:**
- トランザクション実行制御
- キューイング制御
- テストシナリオ実行 (`testTransactions`関数)

### テスト実行パラメータ
`testTransactions`関数は以下の引数で動作をカスタマイズできる:
- transactionType: トランザクションの種類("runTransaction"固定)
- useQueue: キューイングを使用するかどうか(true/false)
- numTickets: テストで使用するチケット数(デフォルト30枚)
- concurrentUserCount: 同時アクセスユーザー数(デフォルト50人)

## 実行方法について
1. `docker-compose build` でイメージをビルド
2. `docker-compose up` でコンテナを起動
3. index.jsの最下部にある`testTransactions`関数の引数を必要に応じて調整
4. `docker-compose run app node /wkspace/index.js`を実行
4. コンソールに出力される実行結果を確認

## ログの内容について
実行結果のログには以下のような情報が出力される:
### 各トランザクション更新の処理
トランザクションのリトライ回数、トランザクション内で取得したドキュメント等の情報が出力される。
トランザクション内での取得(悲観ロック)で取得しているため、キューを使わないで実行した場合は複数のトランザクションが同一のドキュメントを参照していることがわかる。
```
[Transaction 1] Transaction attempt #1 started.
[Transaction 1] { ticket_id: 1, ticket_rank: 1, owner_id: 0, is_sold: false }
[Transaction 1] Ticket updated successfully.
[Transaction 1] Transaction took 184ms
```

### 処理結果
トランザクションを一斉に走らせた結果、チケットの購入状態がどうなったか出力される。
パラメータを変えて実行することで、Failed Transactionsの数や理由が変動する。
キューを使わずに大量に並行して処理したり、キューのリトライの設定が短すぎるとタイムアウトになるケースが多発する。

トランザクションごとのチケット購入(更新処理)の成功有無
```
Successful Transactions: [
  { label: 'Transaction 1', ticketId: '1', retries: 1 },
  { label: 'Transaction 3', ticketId: '4', retries: 2 },
  { label: 'Transaction 4', ticketId: '3', retries: 2 },
  { label: 'Transaction 7', ticketId: '5', retries: 2 },
  { label: 'Transaction 10', ticketId: '2', retries: 1 }
]
Failed Transactions: [
  { label: 'Transaction 2', reason: 'No tickets available' },
  { label: 'Transaction 5', reason: 'No tickets available' },
  { label: 'Transaction 6', reason: 'No tickets available' },
  { label: 'Transaction 8', reason: 'No tickets available' },
  { label: 'Transaction 9', reason: 'No tickets available' }
]
```
チケットの最終の更新結果
```
Final state of tickets:
{
  ticket_id: 1,
  ticket_rank: 1,
  is_sold: true,
  owner_id: 'Transaction 1'
}
{
  ticket_id: 2,
  ticket_rank: 1,
  is_sold: true,
  owner_id: 'Transaction 10'
}
```

## useQueueをfalseにした場合
Firestoreとしての悲観ロック(実質的には楽観ロック)を使用しながら、複数のトランザクションが同時にチケットを購入しようとして処理を実行する。クエリ結果を見るとわかるが、複数のトランザクションが同じドキュメントを更新しようと取り合い、何度もトランザクションのリトライが発生する。同時実行のユーザー数が多いと、チケットが残っているにもかかわらずタイムアウトになるケースが多発する。

## useQueueをtrueにした場合
キュー用のコレクションに自身を登録し、実行後に削除するシンプルなキューを用意している。一定間隔でポーリングし、自分の番が来ると処理を開始する。順序処理になるため1つずつ処理されていくが、ポーリング間隔を長くすると処理時間が非常に長くなる。短くするとリトライの上限にすぐ抵触してタイムアウトが多発してしまう様子が確認できる。

サービスにおいて同時実行数の想定件数を踏まえてこの辺りを設計することが推奨される。同時実行数の想定がかなり少ないのであれば、Firestoreの悲観ロック(実質楽観ロック)の仕組みに準じた、自動リトライでの復旧を前提とした仕組みで十分かもしれない。